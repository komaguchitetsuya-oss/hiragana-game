<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="„Å≤„Çâ„Åå„Å™">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#FFF5E6">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<link rel="icon" type="image/svg+xml" href="icon.svg">
<title>„Å≤„Çâ„Åå„Å™ „Çà„ÇÅ„Çã„Åã„Å™Ôºü</title>
<style>
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --bg-start: #FFF5E6;
  --bg-end: #FFE0F0;
  --text-main: #4A3728;
  --star-color: #FFD700;
  --star-outline: #E6A800;
  --mic-color: #FF4757;
  --mic-hover: #FF6B6B;
  --correct-color: #2ED573;
  --correct-bg: #E8FFF0;
  --retry-color: #FFA502;
  --retry-bg: #FFF8E8;
  --btn-shadow: rgba(0,0,0,0.15);
  --level-colors: #FF6B6B, #FECA57, #48DBFB, #FF9FF3;
}

html, body {
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
  overscroll-behavior: none;
  -webkit-overflow-scrolling: touch;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: "Hiragino Sans", "Hiragino Kaku Gothic Pro", "Noto Sans JP", "Yu Gothic", sans-serif;
  background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
  color: var(--text-main);
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  min-height: 100dvh;
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}

.screen {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 500px;
  height: 100vh;
  height: 100dvh;
  padding: 20px;
  padding-top: calc(20px + env(safe-area-inset-top));
  padding-bottom: calc(20px + env(safe-area-inset-bottom));
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
}

.screen.active {
  display: flex;
}

/* ===== SPLASH SCREEN ===== */
#splash-screen .title {
  font-size: clamp(28px, 8vw, 48px);
  font-weight: 900;
  text-align: center;
  margin-bottom: 10px;
  background: linear-gradient(135deg, #FF6B6B, #FECA57, #48DBFB, #FF9FF3);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

#splash-screen .subtitle {
  font-size: clamp(16px, 4vw, 24px);
  color: #888;
  margin-bottom: 50px;
}

.play-btn {
  width: clamp(160px, 40vw, 220px);
  height: clamp(160px, 40vw, 220px);
  border-radius: 50%;
  border: none;
  background: linear-gradient(145deg, #FF9FF3, #F368E0);
  color: white;
  font-size: clamp(28px, 7vw, 40px);
  font-weight: 900;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 8px 25px rgba(243, 104, 224, 0.4);
  animation: playPulse 2s ease-in-out infinite;
  transition: transform 0.1s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

.play-btn:active {
  transform: scale(0.95);
  animation: none;
}

.play-btn .play-icon {
  font-size: clamp(36px, 9vw, 52px);
}

.continue-btn {
  margin-top: 30px;
  padding: 15px 30px;
  border: 2px solid #DDD;
  border-radius: 25px;
  background: white;
  color: #888;
  font-size: clamp(14px, 3.5vw, 18px);
  font-family: inherit;
  cursor: pointer;
  transition: transform 0.1s;
  display: none;
}

.continue-btn:active {
  transform: scale(0.95);
}

.continue-btn.visible {
  display: block;
}

/* ===== GAME SCREEN ===== */
#game-screen {
  justify-content: flex-start;
  padding-top: 15px;
}

.top-bar {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 5px;
  margin-bottom: 8px;
}

.stars-count {
  font-size: clamp(18px, 5vw, 26px);
  font-weight: 700;
  color: var(--star-color);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.level-badge {
  font-size: clamp(14px, 3.5vw, 18px);
  font-weight: 700;
  padding: 5px 15px;
  border-radius: 20px;
  background: white;
  box-shadow: 0 2px 8px var(--btn-shadow);
}

.top-icons {
  display: flex;
  gap: 8px;
}

.icon-btn {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: none;
  background: white;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 0 2px 8px var(--btn-shadow);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.1s;
}

.icon-btn:active {
  transform: scale(0.9);
}

.progress-container {
  width: 100%;
  height: 12px;
  background: rgba(255,255,255,0.6);
  border-radius: 6px;
  overflow: hidden;
  margin-bottom: 10px;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
}

.progress-fill {
  height: 100%;
  border-radius: 6px;
  background: linear-gradient(90deg, #FECA57, #FF6B6B);
  transition: width 0.5s ease;
}

.word-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  gap: 10px;
}

.word-display {
  font-size: clamp(48px, 18vw, 120px);
  font-weight: 900;
  letter-spacing: 0.05em;
  color: var(--text-main);
  animation: wordEntrance 0.6s ease-out;
  text-align: center;
  line-height: 1.2;
  word-break: keep-all;
  max-width: 95%;
}

.hint-btn {
  padding: 12px 25px;
  border: none;
  border-radius: 25px;
  background: linear-gradient(145deg, #48DBFB, #0ABDE3);
  color: white;
  font-size: clamp(16px, 4vw, 22px);
  font-family: inherit;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(10, 189, 227, 0.3);
  transition: transform 0.1s;
  display: flex;
  align-items: center;
  gap: 8px;
}

.hint-btn:active {
  transform: scale(0.95);
}

.mic-area {
  padding-bottom: 30px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.mic-btn {
  width: clamp(120px, 35vw, 160px);
  height: clamp(120px, 35vw, 160px);
  border-radius: 50%;
  border: none;
  background: linear-gradient(145deg, var(--mic-hover), var(--mic-color));
  color: white;
  font-size: clamp(40px, 12vw, 60px);
  cursor: pointer;
  box-shadow: 0 8px 25px rgba(255, 71, 87, 0.4);
  animation: micPulse 2s ease-in-out infinite;
  transition: transform 0.1s, background 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.mic-btn:active {
  transform: scale(0.95);
  animation: none;
}

.mic-btn.listening {
  background: linear-gradient(145deg, #FF4757, #C0392B);
  animation: none;
  box-shadow: 0 0 0 0 rgba(255,71,87,0.7);
  animation: listeningPulse 1s ease-in-out infinite;
}

.mic-btn:disabled {
  opacity: 0.4;
  animation: none;
  cursor: default;
}

.mic-label {
  font-size: clamp(14px, 3.5vw, 18px);
  font-weight: 700;
  color: #999;
}

/* Listening wave indicator */
.listening-indicator {
  display: none;
  align-items: flex-end;
  justify-content: center;
  gap: 4px;
  height: 40px;
}

.listening-indicator.active {
  display: flex;
}

.listening-bar {
  width: 6px;
  background: var(--mic-color);
  border-radius: 3px;
  animation: listeningWave 0.8s ease-in-out infinite;
}

.listening-bar:nth-child(1) { animation-delay: 0s; height: 15px; }
.listening-bar:nth-child(2) { animation-delay: 0.1s; height: 25px; }
.listening-bar:nth-child(3) { animation-delay: 0.2s; height: 35px; }
.listening-bar:nth-child(4) { animation-delay: 0.1s; height: 25px; }
.listening-bar:nth-child(5) { animation-delay: 0s; height: 15px; }

/* ===== FEEDBACK OVERLAYS ===== */
.feedback-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  pointer-events: none;
}

.feedback-overlay.active {
  display: flex;
  pointer-events: auto;
}

#correct-overlay {
  background: radial-gradient(circle, rgba(255,215,0,0.25) 0%, rgba(46,213,115,0.15) 60%, rgba(46,213,115,0.05) 100%);
}

#retry-overlay {
  background: rgba(255, 165, 2, 0.1);
}

.feedback-text {
  font-size: clamp(40px, 12vw, 72px);
  font-weight: 900;
  animation: bounceIn 0.5s ease-out;
}

#correct-overlay .feedback-text {
  color: var(--correct-color);
}

#retry-overlay .feedback-text {
  color: var(--retry-color);
  font-size: clamp(28px, 8vw, 48px);
}

.feedback-sub {
  font-size: clamp(18px, 5vw, 28px);
  font-weight: 700;
  margin-top: 10px;
  animation: bounceIn 0.5s ease-out 0.15s both;
}

#retry-overlay .feedback-sub {
  color: var(--retry-color);
}

.next-btn {
  margin-top: 30px;
  padding: 15px 40px;
  border: none;
  border-radius: 30px;
  background: white;
  color: var(--text-main);
  font-size: clamp(18px, 5vw, 24px);
  font-weight: 700;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 4px 15px var(--btn-shadow);
  animation: bounceIn 0.5s ease-out 0.3s both;
  transition: transform 0.1s;
}

.next-btn:active {
  transform: scale(0.95);
}

/* Star particles */
.star-particle {
  position: fixed;
  font-size: 30px;
  pointer-events: none;
  z-index: 101;
  animation: starFloat 1.2s ease-out forwards;
}

/* ===== LEVEL COMPLETE SCREEN ===== */
#level-complete-screen {
  z-index: 200;
}

.level-complete-title {
  font-size: clamp(24px, 7vw, 40px);
  font-weight: 900;
  margin-bottom: 5px;
  animation: bounceIn 0.6s ease-out;
}

.level-complete-name {
  font-size: clamp(48px, 14vw, 80px);
  font-weight: 900;
  background: linear-gradient(135deg, #FECA57, #FF6B6B);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: bounceIn 0.6s ease-out 0.2s both;
}

.level-stars {
  font-size: clamp(30px, 8vw, 50px);
  margin: 20px 0;
  animation: bounceIn 0.6s ease-out 0.4s both;
}

.level-next-btn {
  padding: 18px 50px;
  border: none;
  border-radius: 30px;
  background: linear-gradient(145deg, #FECA57, #FF6B6B);
  color: white;
  font-size: clamp(20px, 6vw, 30px);
  font-weight: 900;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
  animation: bounceIn 0.6s ease-out 0.6s both;
  transition: transform 0.1s;
}

.level-next-btn:active {
  transform: scale(0.95);
}

/* ===== ALL CLEAR SCREEN ===== */
#all-clear-screen {
  z-index: 200;
}

.all-clear-title {
  font-size: clamp(32px, 9vw, 56px);
  font-weight: 900;
  background: linear-gradient(135deg, #FF6B6B, #FECA57, #48DBFB, #FF9FF3);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: bounceIn 0.6s ease-out;
  text-align: center;
}

.all-clear-sub {
  font-size: clamp(18px, 5vw, 28px);
  font-weight: 700;
  margin: 15px 0 5px;
  animation: bounceIn 0.6s ease-out 0.2s both;
}

.all-clear-stars {
  font-size: clamp(24px, 7vw, 40px);
  font-weight: 900;
  color: var(--star-color);
  animation: bounceIn 0.6s ease-out 0.4s both;
}

.restart-btn {
  margin-top: 30px;
  padding: 18px 50px;
  border: none;
  border-radius: 30px;
  background: linear-gradient(145deg, #FF9FF3, #F368E0);
  color: white;
  font-size: clamp(18px, 5vw, 26px);
  font-weight: 900;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 8px 25px rgba(243, 104, 224, 0.4);
  animation: bounceIn 0.6s ease-out 0.6s both;
  transition: transform 0.1s;
}

.restart-btn:active {
  transform: scale(0.95);
}

/* ===== FALLBACK MODE ===== */
.fallback-buttons {
  display: none;
  gap: 20px;
  margin-top: 10px;
}

.fallback-buttons.active {
  display: flex;
}

.fallback-btn {
  width: clamp(100px, 28vw, 130px);
  height: clamp(100px, 28vw, 130px);
  border-radius: 25px;
  border: none;
  font-size: clamp(16px, 4vw, 22px);
  font-weight: 900;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 6px 20px var(--btn-shadow);
  transition: transform 0.1s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

.fallback-btn:active {
  transform: scale(0.95);
}

.fallback-correct {
  background: linear-gradient(145deg, #2ED573, #26B860);
  color: white;
}

.fallback-retry {
  background: linear-gradient(145deg, #FECA57, #E8B430);
  color: white;
}

.fallback-icon {
  font-size: clamp(30px, 8vw, 44px);
}

/* ===== CONFETTI ===== */
.confetti-piece {
  position: fixed;
  top: -20px;
  width: 12px;
  height: 12px;
  border-radius: 2px;
  pointer-events: none;
  z-index: 199;
  animation: confettiFall var(--fall-duration) linear forwards;
  animation-delay: var(--fall-delay);
}

/* ===== ANIMATIONS ===== */
@keyframes playPulse {
  0%, 100% { transform: scale(1); box-shadow: 0 8px 25px rgba(243, 104, 224, 0.4); }
  50% { transform: scale(1.05); box-shadow: 0 12px 35px rgba(243, 104, 224, 0.6); }
}

@keyframes micPulse {
  0% { box-shadow: 0 0 0 0 rgba(255,71,87,0.6); }
  70% { box-shadow: 0 0 0 25px rgba(255,71,87,0); }
  100% { box-shadow: 0 0 0 0 rgba(255,71,87,0); }
}

@keyframes listeningPulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255,71,87,0.5); }
  50% { box-shadow: 0 0 0 15px rgba(255,71,87,0); }
}

@keyframes wordEntrance {
  0% { transform: scale(0.3) translateY(-30px); opacity: 0; }
  60% { transform: scale(1.08) translateY(5px); opacity: 1; }
  80% { transform: scale(0.97) translateY(-3px); }
  100% { transform: scale(1) translateY(0); }
}

@keyframes bounceIn {
  0% { transform: scale(0.3); opacity: 0; }
  50% { transform: scale(1.1); }
  70% { transform: scale(0.95); }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes starFloat {
  0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
  100% { transform: translateY(-180px) rotate(720deg) scale(0.3); opacity: 0; }
}

@keyframes listeningWave {
  0%, 100% { transform: scaleY(0.4); }
  50% { transform: scaleY(1); }
}

@keyframes confettiFall {
  0% { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(calc(100vh + 20px)) rotate(var(--fall-rotation)); opacity: 0.5; }
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
</style>
</head>
<body>

<!-- ===== SPLASH SCREEN ===== -->
<div id="splash-screen" class="screen active">
  <div class="title">„Å≤„Çâ„Åå„Å™<br>„Çà„ÇÅ„Çã„Åã„Å™Ôºü</div>
  <div class="subtitle">„Åä„Å®„ÅÆ „Å°„Åã„Çâ„Åß „ÉÅ„É£„É¨„É≥„Ç∏ÔºÅ</div>
  <button class="play-btn" id="play-btn">
    <span class="play-icon">‚ñ∂</span>
    „ÅÇ„Åù„Å∂
  </button>
  <button class="continue-btn" id="continue-btn">„Å§„Å•„Åç„Åã„Çâ „ÅÇ„Åù„Å∂</button>
</div>

<!-- ===== GAME SCREEN ===== -->
<div id="game-screen" class="screen">
  <div class="top-bar">
    <div class="stars-count" id="stars-count">‚òÖ 0</div>
    <div class="level-badge" id="level-badge">„É¨„Éô„É´ 1</div>
    <div class="top-icons">
      <button class="icon-btn" id="sound-toggle" title="„Åä„Å®">‚ô™</button>
      <button class="icon-btn" id="home-btn" title="„Éõ„Éº„É†">üè†</button>
    </div>
  </div>

  <div class="progress-container">
    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
  </div>

  <div class="word-area">
    <div class="word-display" id="word-display">„ÅÇ</div>
    <button class="hint-btn" id="hint-btn">
      üîä „Åç„ÅÑ„Å¶„Åø„Çã
    </button>
  </div>

  <div class="mic-area">
    <div class="listening-indicator" id="listening-indicator">
      <div class="listening-bar"></div>
      <div class="listening-bar"></div>
      <div class="listening-bar"></div>
      <div class="listening-bar"></div>
      <div class="listening-bar"></div>
    </div>
    <button class="mic-btn" id="mic-btn">üé§</button>
    <div class="mic-label" id="mic-label">„Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ</div>

    <!-- Fallback buttons for browsers without speech recognition -->
    <div class="fallback-buttons" id="fallback-buttons">
      <button class="fallback-btn fallback-correct" id="fallback-correct-btn">
        <span class="fallback-icon">‚≠ï</span>
        „Åß„Åç„ÅüÔºÅ
      </button>
      <button class="fallback-btn fallback-retry" id="fallback-retry-btn">
        <span class="fallback-icon">üîÑ</span>
        „ÇÇ„ÅÜ„ÅÑ„Å°„Å©
      </button>
    </div>
  </div>
</div>

<!-- ===== CORRECT FEEDBACK OVERLAY ===== -->
<div id="correct-overlay" class="feedback-overlay">
  <div class="feedback-text" id="correct-text">„Åô„Åî„ÅÑÔºÅ</div>
  <div class="feedback-sub" id="correct-sub">‚òÖ +1</div>
  <button class="next-btn" id="next-btn">„Å§„Åé„Å∏ ‚ñ∂</button>
</div>

<!-- ===== RETRY FEEDBACK OVERLAY ===== -->
<div id="retry-overlay" class="feedback-overlay">
  <div class="feedback-text" id="retry-text">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©</div>
  <div class="feedback-sub" id="retry-sub">„ÇÑ„Å£„Å¶„Åø„Çà„ÅÜÔºÅ</div>
</div>

<!-- ===== LEVEL COMPLETE SCREEN ===== -->
<div id="level-complete-screen" class="screen">
  <div class="level-complete-title">„ÇØ„É™„Ç¢ÔºÅ</div>
  <div class="level-complete-name" id="level-complete-name">„Å≤„Çà„Åì</div>
  <div class="level-stars" id="level-stars">‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
  <button class="level-next-btn" id="level-next-btn">„Å§„Åé„ÅÆ „É¨„Éô„É´„Å∏ ‚ñ∂</button>
</div>

<!-- ===== ALL CLEAR SCREEN ===== -->
<div id="all-clear-screen" class="screen">
  <div class="all-clear-title">„Åú„Çì„Å∂ „ÇØ„É™„Ç¢ÔºÅ<br>„Åô„Åî„ÅÑ„Å≠ÔºÅ</div>
  <div class="all-clear-sub">„ÅÇ„Å§„ÇÅ„Åü „Åª„Åó</div>
  <div class="all-clear-stars" id="all-clear-stars">‚òÖ 0</div>
  <button class="restart-btn" id="restart-btn">„ÅØ„Åò„ÇÅ„Åã„Çâ „ÅÇ„Åù„Å∂</button>
</div>

<script>
// ===== WORD BANK =====
const WORD_BANK = {
  1: {
    name: '„Å≤„Çà„Åì',
    emoji: 'üê£',
    wordsPerRound: 5,
    words: [
      { word: '„ÅÑ„Å°„Åî', reading: '„ÅÑ„Å°„Åî' },
      { word: '„ÅÜ„Åï„Åé', reading: '„ÅÜ„Åï„Åé' },
      { word: '„Åø„Åã„Çì', reading: '„Åø„Åã„Çì' },
      { word: '„Åè„Çã„Åæ', reading: '„Åè„Çã„Åæ' },
      { word: '„Å∞„Å™„Å™', reading: '„Å∞„Å™„Å™' },
      { word: '„Åü„Åæ„Åî', reading: '„Åü„Åæ„Åî' },
      { word: '„Çä„Çì„Åî', reading: '„Çä„Çì„Åî' },
      { word: '„Åï„Åè„Çâ', reading: '„Åï„Åè„Çâ' },
      { word: '„Å®„Åæ„Å®', reading: '„Å®„Åæ„Å®' },
      { word: '„ÅÇ„Å≤„Çã', reading: '„ÅÇ„Å≤„Çã' },
    ]
  },
  2: {
    name: '„ÅÜ„Åï„Åé',
    emoji: 'üê∞',
    wordsPerRound: 6,
    words: [
      { word: '„Åä„Å´„Åé„Çä', reading: '„Åä„Å´„Åé„Çä' },
      { word: '„Å≤„Åì„ÅÜ„Åç', reading: '„Å≤„Åì„ÅÜ„Åç' },
      { word: '„Åü„Çì„ÅΩ„ÅΩ', reading: '„Åü„Çì„ÅΩ„ÅΩ' },
      { word: '„Åó„Åæ„ÅÜ„Åæ', reading: '„Åó„Åæ„ÅÜ„Åæ' },
      { word: '„Å≤„Åæ„Çè„Çä', reading: '„Å≤„Åæ„Çè„Çä' },
      { word: '„Åß„Çì„Åó„ÇÉ', reading: '„Åß„Çì„Åó„ÇÉ' },
      { word: '„Åç„Çì„Åé„Çá', reading: '„Åç„Çì„Åé„Çá' },
      { word: '„ÅÇ„Åï„Åå„Åä', reading: '„ÅÇ„Åï„Åå„Åä' },
      { word: '„Åä„Åï„Åã„Å™', reading: '„Åä„Åï„Åã„Å™' },
      { word: '„Åô„ÅÑ„Åû„Åè', reading: '„Åô„ÅÑ„Åû„Åè' },
    ]
  },
  3: {
    name: '„ÅÑ„Çã„Åã',
    emoji: 'üê¨',
    wordsPerRound: 6,
    words: [
      { word: '„Åã„Åü„Å§„ÇÄ„Çä', reading: '„Åã„Åü„Å§„ÇÄ„Çä' },
      { word: '„Åä„Åã„ÅÇ„Åï„Çì', reading: '„Åä„Åã„ÅÇ„Åï„Çì' },
      { word: '„Åä„Å®„ÅÜ„Åï„Çì', reading: '„Åä„Å®„ÅÜ„Åï„Çì' },
      { word: '„Åä„Å®„ÇÇ„Å†„Å°', reading: '„Åä„Å®„ÇÇ„Å†„Å°' },
      { word: '„Åì„ÅÑ„ÅÆ„Åº„Çä', reading: '„Åì„ÅÑ„ÅÆ„Åº„Çä' },
      { word: '„Åã„Å∂„Å®„ÇÄ„Åó', reading: '„Åã„Å∂„Å®„ÇÄ„Åó' },
      { word: '„Åä„Åπ„Çì„Å®„ÅÜ', reading: '„Åä„Åπ„Çì„Å®„ÅÜ' },
      { word: '„Å†„Çì„Åî„ÇÄ„Åó', reading: '„Å†„Çì„Åî„ÇÄ„Åó' },
      { word: '„ÅØ„Çì„Å∞„Éº„Åê', reading: '„ÅØ„Çì„Å∞„Éº„Åê' },
      { word: '„Åã„Åç„Åî„Åä„Çä', reading: '„Åã„Åç„Åî„Åä„Çä' },
    ]
  },
  4: {
    name: '„É©„Ç§„Ç™„É≥',
    emoji: 'ü¶Å',
    wordsPerRound: 5,
    words: [
      { word: '„Åä„ÅØ„Çà„ÅÜ', reading: '„Åä„ÅØ„Çà„ÅÜ' },
      { word: '„ÅÇ„Çä„Åå„Å®„ÅÜ', reading: '„ÅÇ„Çä„Åå„Å®„ÅÜ' },
      { word: '„ÅÑ„Åü„Å†„Åç„Åæ„Åô', reading: '„ÅÑ„Åü„Å†„Åç„Åæ„Åô' },
      { word: '„Åî„Å°„Åù„ÅÜ„Åï„Åæ', reading: '„Åî„Å°„Åù„ÅÜ„Åï„Åæ' },
      { word: '„Åä„ÇÑ„Åô„Åø„Å™„Åï„ÅÑ', reading: '„Åä„ÇÑ„Åô„Åø„Å™„Åï„ÅÑ' },
      { word: '„ÅÑ„Å£„Å¶„Åç„Åæ„Åô', reading: '„ÅÑ„Å£„Å¶„Åç„Åæ„Åô' },
      { word: '„Åü„Å†„ÅÑ„Åæ', reading: '„Åü„Å†„ÅÑ„Åæ' },
      { word: '„Åä„Åã„Åà„Çä', reading: '„Åä„Åã„Åà„Çä' },
    ]
  }
};

const LEVEL_COUNT = Object.keys(WORD_BANK).length;

// ===== PRAISE & RETRY MESSAGES =====
const PRAISE_MESSAGES = [
  '„Åô„Å£„Åî„Éº„ÅÑÔºÅÔºÅ', '„ÇÑ„Å£„Åü„ÉºÔºÅÔºÅ', '„Å¶„Çì„Åï„ÅÑÔºÅÔºÅ', '„Åà„Çâ„Éº„ÅÑÔºÅÔºÅ',
  '„Å∞„Å£„Å°„ÇäÔºÅÔºÅ', '„Åã„Å£„Åì„ÅÑ„ÅÑ„ÉºÔºÅÔºÅ', '„Åô„Å∞„Çâ„Åó„ÅÑÔºÅÔºÅ', '„Åã„Çì„Å∫„ÅçÔºÅÔºÅ',
  '„Åß„Åç„Åü„Å≠„ÉºÔºÅÔºÅ', '„Åï„ÅÑ„Åì„ÅÜÔºÅÔºÅ', '„Åô„Åî„Åô„Åé„ÉºÔºÅÔºÅ', '„Å¥„Åã„ÅÑ„Å°ÔºÅÔºÅ',
];

const RETRY_MESSAGES = [
  { main: '„ÇÇ„ÅÜ„ÅÑ„Å°„Å©', sub: '„ÇÑ„Å£„Å¶„Åø„Çà„ÅÜÔºÅ' },
  { main: '„Åä„Åó„ÅÑÔºÅ', sub: '„ÇÇ„ÅÜ„ÅÑ„Å£„Åã„ÅÑÔºÅ' },
  { main: '„Åå„Çì„Å∞„ÇåÔºÅ', sub: '„ÇÇ„ÅÜ„ÅÑ„Å°„Å©ÔºÅ' },
];

// ===== CHILD PRONUNCIATION SUBSTITUTION MAP =====
const CHILD_SUBSTITUTIONS = {
  '„Åï': ['„Åó„ÇÉ', '„Åü', '„Å°„ÇÉ'],
  '„Åó': ['„Å°', '„Å≤'],
  '„Åô': ['„Å°„ÇÖ', '„Å§', '„Åó„ÇÖ'],
  '„Åõ': ['„Åó„Åá', '„Å¶', '„Å°„Åá'],
  '„Åù': ['„Åó„Çá', '„Å®', '„Å°„Çá'],
  '„Çâ': ['„Å†', '„Å™'],
  '„Çä': ['„Åß„ÅÉ', '„Å´', '„ÅÑ', '„Å¢'],
  '„Çã': ['„Å©„ÅÖ', '„Å¨', '„ÅÜ', '„Å©'],
  '„Çå': ['„Åß', '„Å≠'],
  '„Çç': ['„Å©', '„ÅÆ'],
  '„Åã': ['„Åü'],
  '„Åç': ['„Å°'],
  '„Åè': ['„Å§'],
  '„Åë': ['„Å¶'],
  '„Åì': ['„Å®'],
  '„Åñ': ['„Å†'],
  '„Åò': ['„Å¢', '„Åß„ÅÉ'],
  '„Åö': ['„Å•', '„Å©„ÅÖ'],
  '„Åú': ['„Åß', '„Åò„Åá'],
  '„Åû': ['„Å©'],
  '„Å§': ['„Å°„ÇÖ'],
};

// ===== GAME STATE =====
let gameState = {
  currentLevel: 1,
  currentWordIndex: 0,
  wordsInRound: [],
  totalStars: 0,
  starsThisLevel: 0,
  attemptsOnCurrentWord: 0,
  autoPassMode: false,
  soundEnabled: true,
  completedLevels: [],
};

// ===== DOM ELEMENTS =====
const $ = id => document.getElementById(id);

const splashScreen = $('splash-screen');
const gameScreen = $('game-screen');
const levelCompleteScreen = $('level-complete-screen');
const allClearScreen = $('all-clear-screen');
const correctOverlay = $('correct-overlay');
const retryOverlay = $('retry-overlay');

const playBtn = $('play-btn');
const continueBtn = $('continue-btn');
const micBtn = $('mic-btn');
const hintBtn = $('hint-btn');
const nextBtn = $('next-btn');
const levelNextBtn = $('level-next-btn');
const restartBtn = $('restart-btn');
const soundToggle = $('sound-toggle');
const homeBtn = $('home-btn');
const fallbackCorrectBtn = $('fallback-correct-btn');
const fallbackRetryBtn = $('fallback-retry-btn');

const wordDisplay = $('word-display');
const starsCount = $('stars-count');
const levelBadge = $('level-badge');
const progressFill = $('progress-fill');
const micLabel = $('mic-label');
const listeningIndicator = $('listening-indicator');
const fallbackButtons = $('fallback-buttons');

// ===== SOUND EFFECTS (Web Audio API) =====
let audioCtx = null;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTone(frequency, duration, type = 'sine', volume = 0.25) {
  if (!audioCtx || !gameState.soundEnabled) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
  gain.gain.setValueAtTime(volume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playCorrectSound() {
  playTone(523.25, 0.15);
  setTimeout(() => playTone(659.25, 0.15), 100);
  setTimeout(() => playTone(783.99, 0.3), 200);
}

function playRetrySound() {
  playTone(440, 0.15, 'sine', 0.15);
  setTimeout(() => playTone(349.23, 0.2, 'sine', 0.15), 150);
}

function playLevelUpSound() {
  const notes = [523.25, 587.33, 659.25, 698.46, 783.99, 880, 987.77, 1046.5];
  notes.forEach((freq, i) => {
    setTimeout(() => playTone(freq, 0.15), i * 80);
  });
}

function playStarSound() {
  playTone(1200, 0.08);
  setTimeout(() => playTone(1600, 0.08), 60);
  setTimeout(() => playTone(2000, 0.1), 120);
}

function playTapSound() {
  playTone(800, 0.05);
}

function playCelebrationSFX() {
  if (!audioCtx || !gameState.soundEnabled) return;
  // Cheering whoops: ascending frequency sweeps
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      const t = audioCtx.currentTime;
      osc.frequency.setValueAtTime(500 + i * 200, t);
      osc.frequency.exponentialRampToValueAtTime(1400 + i * 300, t + 0.18);
      gain.gain.setValueAtTime(0.13, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + 0.3);
    }, i * 160);
  }
  // Clapping: short filtered noise bursts
  for (let i = 0; i < 6; i++) {
    setTimeout(() => {
      if (!audioCtx) return;
      const bufSize = Math.floor(audioCtx.sampleRate * 0.035);
      const buffer = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let j = 0; j < bufSize; j++) {
        data[j] = (Math.random() * 2 - 1) * Math.exp(-j / (bufSize * 0.25));
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 3000;
      filter.Q.value = 0.7;
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
      src.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      src.start();
    }, 500 + i * 110);
  }
  // Whistle: descending then ascending tone
  setTimeout(() => {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    const t = audioCtx.currentTime;
    osc.frequency.setValueAtTime(1800, t);
    osc.frequency.exponentialRampToValueAtTime(1200, t + 0.12);
    osc.frequency.exponentialRampToValueAtTime(2000, t + 0.3);
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 0.35);
  }, 1200);
}

// ===== BGM (Procedural cheerful melody) =====
let bgmPlaying = false;
let bgmNodes = [];

function startBGM() {
  if (!audioCtx || bgmPlaying || !gameState.soundEnabled) return;
  bgmPlaying = true;

  // Cheerful pentatonic melody in C major
  const bpm = 140;
  const beatLen = 60 / bpm;
  const melodyNotes = [
    // Bar 1-2: upbeat opening
    523, 587, 659, 784, 659, 587, 523, 0,
    659, 784, 880, 784, 659, 784, 659, 0,
    // Bar 3-4: playful bounce
    784, 880, 784, 659, 523, 659, 784, 0,
    880, 784, 659, 523, 587, 659, 523, 0,
  ];
  const bassNotes = [
    262, 262, 330, 330, 262, 262, 330, 330,
    349, 349, 392, 392, 349, 349, 262, 262,
    262, 262, 330, 330, 349, 349, 392, 392,
    349, 349, 262, 262, 330, 330, 262, 262,
  ];

  const loopLen = melodyNotes.length * beatLen * 0.5;

  function scheduleLoop() {
    if (!bgmPlaying || !audioCtx) return;
    const now = audioCtx.currentTime;

    melodyNotes.forEach((freq, i) => {
      if (freq === 0) return;
      const t = now + i * beatLen * 0.5;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(freq, t);
      gain.gain.setValueAtTime(0.06, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + beatLen * 0.45);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + beatLen * 0.5);
      bgmNodes.push(osc);
    });

    bassNotes.forEach((freq, i) => {
      const t = now + i * beatLen * 0.5;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, t);
      gain.gain.setValueAtTime(0.04, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + beatLen * 0.45);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + beatLen * 0.5);
      bgmNodes.push(osc);
    });

    // Schedule next loop
    gameState._bgmTimer = setTimeout(scheduleLoop, (loopLen - 0.1) * 1000);
  }

  scheduleLoop();
}

function stopBGM() {
  bgmPlaying = false;
  clearTimeout(gameState._bgmTimer);
  bgmNodes.forEach(n => { try { n.stop(); } catch(e){} });
  bgmNodes = [];
}

// ===== SPEECH SYNTHESIS =====
let cachedVoices = [];

function loadVoices() {
  cachedVoices = speechSynthesis.getVoices();
}

if (typeof speechSynthesis !== 'undefined') {
  speechSynthesis.onvoiceschanged = loadVoices;
  loadVoices();
}

function speakWord(text) {
  if (!gameState.soundEnabled) return;
  speechSynthesis.cancel();
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'ja-JP';
  utterance.rate = 0.8;
  utterance.pitch = 1.2;
  const jaVoice = cachedVoices.find(v => v.lang.startsWith('ja'));
  if (jaVoice) utterance.voice = jaVoice;
  speechSynthesis.speak(utterance);
}

// ===== SPEECH RECOGNITION =====
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;
let hasSpeechRecognition = !!SpeechRecognition;
let recognitionActive = false;
let recognitionGotResult = false;
let recognitionFailCount = 0;

// iOS Safari requires creating a fresh SpeechRecognition instance each time
function createRecognition() {
  if (!SpeechRecognition) return null;
  const rec = new SpeechRecognition();
  rec.lang = 'ja-JP';
  rec.continuous = false;
  rec.interimResults = false;
  rec.maxAlternatives = 10;
  rec.onresult = handleRecognitionResult;
  rec.onerror = handleRecognitionError;
  rec.onend = handleRecognitionEnd;
  return rec;
}

function initSpeechRecognition() {
  if (!SpeechRecognition) {
    hasSpeechRecognition = false;
    return;
  }
  try {
    const test = new SpeechRecognition();
    hasSpeechRecognition = true;
  } catch (e) {
    hasSpeechRecognition = false;
  }
}

function startRecognition() {
  if (!SpeechRecognition || recognitionActive) return;
  // Always try ‚Äî don't give up permanently
  recognition = createRecognition();
  if (!recognition) return;
  try {
    recognitionActive = true;
    recognitionGotResult = false;
    recognition.start();
    micBtn.classList.add('listening');
    listeningIndicator.classList.add('active');
    micLabel.textContent = '„Åç„ÅÑ„Å¶„Çã„Çà‚Ä¶';
    // Safety timeout: if nothing happens in 8s, auto-restart
    gameState._recTimeout = setTimeout(() => {
      if (recognitionActive) {
        stopRecognition();
        micLabel.textContent = '„ÇÇ„ÅÜ„ÅÑ„Å°„Å© „Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ';
        setTimeout(() => startRecognition(), 1500);
      }
    }, 8000);
  } catch (e) {
    recognitionActive = false;
    micBtn.classList.remove('listening');
    listeningIndicator.classList.remove('active');
    recognitionFailCount++;
    // Retry after a pause instead of giving up
    micLabel.textContent = '„ÇÇ„ÅÜ„ÅÑ„Å°„Å© „Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ';
    if (recognitionFailCount < 5) {
      setTimeout(() => startRecognition(), 2000);
    }
  }
}

function stopRecognition() {
  clearTimeout(gameState._recTimeout);
  if (recognition) {
    try { recognition.stop(); } catch (e) { /* ignore */ }
    try { recognition.abort(); } catch (e) { /* ignore */ }
  }
  recognitionActive = false;
  micBtn.classList.remove('listening');
  listeningIndicator.classList.remove('active');
  micLabel.textContent = '„Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ';
}

function handleRecognitionResult(event) {
  recognitionGotResult = true;
  recognitionFailCount = 0; // Reset fail counter on success
  stopRecognition();
  const results = event.results[0];
  const alternatives = [];
  for (let i = 0; i < results.length; i++) {
    alternatives.push(results[i].transcript.trim());
  }

  const target = getCurrentWord().reading;
  const matchResult = checkMatch(target, alternatives);

  if (matchResult.match || gameState.autoPassMode) {
    gameState.autoPassMode = false;
    showCorrectFeedback();
  } else {
    gameState.attemptsOnCurrentWord++;
    if (gameState.attemptsOnCurrentWord >= 3) {
      showAutoPassHint();
    } else {
      showRetryFeedback();
    }
  }
}

function handleRecognitionError(event) {
  stopRecognition();
  if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
    // Mic permission denied ‚Äî show message but don't permanently disable
    micLabel.textContent = '„Éû„Ç§„ÇØ„Éú„Çø„É≥„Çí „Åä„Åó„Å¶„Å≠';
    recognitionFailCount++;
  } else if (event.error === 'no-speech') {
    micLabel.textContent = '„ÇÇ„ÅÜ„ÅÑ„Å°„Å© „Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ';
    // Auto-restart after no-speech
    setTimeout(() => startRecognition(), 1500);
  } else {
    micLabel.textContent = '„Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ';
    // Auto-restart on other errors
    setTimeout(() => startRecognition(), 2000);
  }
}

function handleRecognitionEnd() {
  // On iOS Safari, onend fires even on success ‚Äî only reset UI if no result came
  if (recognitionActive && !recognitionGotResult) {
    stopRecognition();
    micLabel.textContent = '„ÇÇ„ÅÜ„ÅÑ„Å°„Å© „Åä„ÅØ„Å™„Åó „Åó„Å¶„Å≠ÔºÅ';
    setTimeout(() => startRecognition(), 1500);
  }
}

// ===== FUZZY MATCHING =====
function normalizeToHiragana(text) {
  return text.replace(/[\u30A1-\u30F6]/g, ch =>
    String.fromCharCode(ch.charCodeAt(0) - 0x60)
  ).replace(/[\u30FC]/g, '„Éº');
}

function generateChildVariants(targetWord) {
  let variants = [''];
  for (const char of targetWord) {
    const options = [char, ...(CHILD_SUBSTITUTIONS[char] || [])];
    const newVariants = [];
    for (const variant of variants) {
      for (const option of options) {
        newVariants.push(variant + option);
      }
    }
    variants = newVariants;
    // Safety: cap at 200 variants
    if (variants.length > 200) {
      variants = variants.slice(0, 200);
    }
  }
  return variants;
}

function levenshteinDistance(a, b) {
  const m = a.length, n = b.length;
  const d = Array.from({ length: m + 1 }, (_, i) => [i]);
  for (let j = 1; j <= n; j++) d[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      d[i][j] = a[i - 1] === b[j - 1]
        ? d[i - 1][j - 1]
        : Math.min(d[i - 1][j - 1] + 1, d[i][j - 1] + 1, d[i - 1][j] + 1);
    }
  }
  return d[m][n];
}

function checkMatch(target, alternatives) {
  // Very lenient matching: "„Åù„Çå„Å£„ÅΩ„Åã„Å£„Åü„ÇâOK"
  const variants = generateChildVariants(target);
  // Generous distance: at least 1, up to half the target length
  const maxDist = Math.max(Math.ceil(target.length * 0.6), 1);

  for (const alt of alternatives) {
    const normalized = normalizeToHiragana(alt);
    const clean = normalized.replace(/[\s„ÄÅ„ÄÇÔºÅÔºü„Éª\-]/g, '');

    // Tier 1: Exact match
    if (clean === target) return { match: true, tier: 1 };

    // Tier 2: Child variant match
    if (variants.includes(clean)) return { match: true, tier: 2 };

    // Tier 3: Generous Levenshtein on target
    if (levenshteinDistance(clean, target) <= maxDist) return { match: true, tier: 3 };

    // Tier 4: Generous Levenshtein on child variants
    for (const v of variants) {
      if (levenshteinDistance(clean, v) <= maxDist) {
        return { match: true, tier: 3 };
      }
    }

    // Tier 5: Substring ‚Äî target in recognized text or vice versa
    if (clean.length >= 1 && (clean.includes(target) || target.includes(clean))) {
      return { match: true, tier: 3 };
    }
    for (const v of variants) {
      if (clean.includes(v) || v.includes(clean)) return { match: true, tier: 3 };
    }

    // Tier 6: First character match (for 2-char words)
    if (target.length <= 2 && clean.length >= 1) {
      const firstCharVariants = [target[0], ...(CHILD_SUBSTITUTIONS[target[0]] || [])];
      if (firstCharVariants.some(fc => clean[0] === fc || clean.includes(fc))) {
        return { match: true, tier: 3 };
      }
    }

    // Tier 7: Shared characters (order-independent) ‚Äî at least half match
    const targetChars = [...target];
    const cleanChars = [...clean];
    let shared = 0;
    const used = new Set();
    for (const c of cleanChars) {
      const idx = targetChars.findIndex((tc, i) => tc === c && !used.has(i));
      if (idx >= 0) { shared++; used.add(idx); }
    }
    if (shared >= Math.ceil(target.length / 2)) return { match: true, tier: 3 };
  }
  return { match: false, tier: 0 };
}

// ===== GAME LOGIC =====
function getCurrentWord() {
  return gameState.wordsInRound[gameState.currentWordIndex];
}

function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function startLevel(level) {
  const bank = WORD_BANK[level];
  if (!bank) {
    showAllClear();
    return;
  }
  gameState.currentLevel = level;
  gameState.currentWordIndex = 0;
  gameState.starsThisLevel = 0;
  gameState.attemptsOnCurrentWord = 0;
  gameState.autoPassMode = false;

  const shuffled = shuffleArray(bank.words);
  gameState.wordsInRound = shuffled.slice(0, bank.wordsPerRound);

  updateUI();
  showScreen(gameScreen);
  showCurrentWord();
}

function showCurrentWord() {
  const word = getCurrentWord();
  wordDisplay.textContent = word.word;
  // Dynamic font size for longer words/sentences
  const len = word.word.length;
  if (len <= 3) wordDisplay.style.fontSize = '';
  else if (len <= 5) wordDisplay.style.fontSize = 'clamp(40px, 14vw, 100px)';
  else if (len <= 7) wordDisplay.style.fontSize = 'clamp(32px, 11vw, 80px)';
  else wordDisplay.style.fontSize = 'clamp(26px, 9vw, 64px)';
  wordDisplay.style.animation = 'none';
  void wordDisplay.offsetWidth; // trigger reflow
  wordDisplay.style.animation = 'wordEntrance 0.6s ease-out';
  gameState.attemptsOnCurrentWord = 0;
  gameState.autoPassMode = false;
  micBtn.disabled = false;
  updateProgress();
  // Auto-start listening after word entrance animation
  micLabel.textContent = '';
  if (SpeechRecognition) {
    setTimeout(() => {
      startRecognition();
    }, 800);
  }
}

function advanceToNextWord() {
  hideOverlays();
  gameState.currentWordIndex++;

  const bank = WORD_BANK[gameState.currentLevel];
  if (gameState.currentWordIndex >= gameState.wordsInRound.length) {
    // Level complete
    if (!gameState.completedLevels.includes(gameState.currentLevel)) {
      gameState.completedLevels.push(gameState.currentLevel);
    }
    gameState.totalStars += 5; // level bonus
    saveProgress();
    showLevelComplete();
  } else {
    showCurrentWord();
  }
}

function showAutoPassHint() {
  // Read the word aloud, then enable auto-pass mode
  const word = getCurrentWord();
  speakWord(word.reading);
  gameState.autoPassMode = true;
  micLabel.textContent = '„ÅÑ„Å£„Åó„Çá„Å´ „ÅÑ„Å£„Å¶„Åø„Çà„ÅÜÔºÅ';
  micBtn.disabled = false;

  // Briefly show hint text
  retryOverlay.classList.add('active');
  $('retry-text').textContent = '„Åç„ÅÑ„Å¶„Åø„Å¶„Å≠';
  $('retry-sub').textContent = '„ÅÑ„Å£„Åó„Çá„Å´ „ÅÑ„Å£„Å¶„Åø„Çà„ÅÜÔºÅ';
  setTimeout(() => {
    retryOverlay.classList.remove('active');
    // Auto-restart listening in auto-pass mode
    if (SpeechRecognition) {
      setTimeout(() => startRecognition(), 500);
    }
  }, 2500);
}

// ===== FEEDBACK =====
function showCorrectFeedback() {
  stopRecognition();

  const isFirstTry = gameState.attemptsOnCurrentWord === 0 && !gameState.autoPassMode;
  const starsEarned = isFirstTry ? 2 : 1;
  gameState.totalStars += starsEarned;
  gameState.starsThisLevel += starsEarned;
  updateUI();
  saveProgress();

  const praise = PRAISE_MESSAGES[Math.floor(Math.random() * PRAISE_MESSAGES.length)];
  $('correct-text').textContent = praise;
  $('correct-sub').textContent = '‚òÖ +' + starsEarned;

  correctOverlay.classList.add('active');

  // Big celebration: multi-wave sound + stars + voice praise
  playCorrectSound();
  spawnStarParticles();
  setTimeout(() => {
    playStarSound();
    spawnStarParticles();
  }, 300);
  setTimeout(() => {
    playStarSound();
    spawnStarParticles();
  }, 600);

  // Celebration sound effects (cheering + clapping, no TTS)
  setTimeout(() => playCelebrationSFX(), 400);
}

function showRetryFeedback() {
  playRetrySound();

  const msg = RETRY_MESSAGES[Math.floor(Math.random() * RETRY_MESSAGES.length)];
  $('retry-text').textContent = msg.main;
  $('retry-sub').textContent = msg.sub;

  retryOverlay.classList.add('active');
  setTimeout(() => {
    retryOverlay.classList.remove('active');
    // Auto-restart listening after retry
    if (SpeechRecognition) {
      setTimeout(() => startRecognition(), 300);
    }
  }, 1500);
}

function showLevelComplete() {
  playLevelUpSound();
  spawnConfetti();

  const bank = WORD_BANK[gameState.currentLevel];
  $('level-complete-name').textContent = bank.emoji + ' ' + bank.name;
  $('level-stars').textContent = '‚òÖ'.repeat(Math.min(gameState.starsThisLevel, 10)) + (gameState.starsThisLevel > 10 ? '‚Ä¶' : '');

  if (gameState.currentLevel >= LEVEL_COUNT) {
    levelNextBtn.textContent = '„Åë„Å£„Åã „Çí„Åø„Çã ‚ñ∂';
  } else {
    levelNextBtn.textContent = '„Å§„Åé„ÅÆ „É¨„Éô„É´„Å∏ ‚ñ∂';
  }

  showScreen(levelCompleteScreen);
}

function showAllClear() {
  spawnConfetti();
  $('all-clear-stars').textContent = '‚òÖ ' + gameState.totalStars;
  showScreen(allClearScreen);
}

function hideOverlays() {
  correctOverlay.classList.remove('active');
  retryOverlay.classList.remove('active');
}

// ===== STAR PARTICLES =====
function spawnStarParticles() {
  const chars = ['‚òÖ', '‚ú¶', '‚ú®', '‚≠ê'];
  const colors = ['#FFD700', '#FF6B6B', '#FF9FF3', '#FECA57', '#48DBFB'];
  for (let i = 0; i < 12; i++) {
    const star = document.createElement('div');
    star.className = 'star-particle';
    star.textContent = chars[Math.floor(Math.random() * chars.length)];
    star.style.left = (Math.random() * 90 + 5) + '%';
    star.style.top = (Math.random() * 40 + 30) + '%';
    star.style.color = colors[Math.floor(Math.random() * colors.length)];
    star.style.fontSize = (Math.random() * 25 + 22) + 'px';
    document.body.appendChild(star);
    star.addEventListener('animationend', () => star.remove());
  }
}

// ===== CONFETTI =====
function spawnConfetti() {
  const colors = ['#FF6B6B', '#FECA57', '#48DBFB', '#FF9FF3', '#2ED573', '#A29BFE'];
  for (let i = 0; i < 40; i++) {
    const piece = document.createElement('div');
    piece.className = 'confetti-piece';
    piece.style.left = (Math.random() * 100) + '%';
    piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    piece.style.setProperty('--fall-duration', (Math.random() * 2 + 2) + 's');
    piece.style.setProperty('--fall-delay', (Math.random() * 1) + 's');
    piece.style.setProperty('--fall-rotation', (Math.random() * 1080 - 540) + 'deg');
    piece.style.width = (Math.random() * 8 + 6) + 'px';
    piece.style.height = (Math.random() * 8 + 6) + 'px';
    piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
    document.body.appendChild(piece);
    piece.addEventListener('animationend', () => piece.remove());
  }
}

// ===== UI UPDATES =====
function updateUI() {
  starsCount.textContent = '‚òÖ ' + gameState.totalStars;
  const bank = WORD_BANK[gameState.currentLevel];
  if (bank) {
    levelBadge.textContent = bank.emoji + ' „É¨„Éô„É´ ' + gameState.currentLevel;
  }
}

function updateProgress() {
  const total = gameState.wordsInRound.length;
  const current = gameState.currentWordIndex;
  const pct = total > 0 ? (current / total * 100) : 0;
  progressFill.style.width = pct + '%';
}

function showScreen(screen) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  screen.classList.add('active');
}

// ===== LOCAL STORAGE =====
const STORAGE_KEY = 'hiragana_game_v1';

function saveProgress() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      version: 1,
      currentLevel: gameState.currentLevel,
      totalStars: gameState.totalStars,
      completedLevels: gameState.completedLevels,
      savedAt: Date.now(),
    }));
  } catch (e) { /* silently fail */ }
}

function loadProgress() {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) return null;
    const parsed = JSON.parse(data);
    if (parsed.version !== 1) return null;
    return parsed;
  } catch (e) {
    return null;
  }
}

function resetProgress() {
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch (e) { /* silently fail */ }
  gameState.currentLevel = 1;
  gameState.totalStars = 0;
  gameState.completedLevels = [];
}

// ===== INIT =====
function init() {
  initSpeechRecognition();

  // Check saved progress
  const saved = loadProgress();
  if (saved && saved.completedLevels && saved.completedLevels.length > 0) {
    continueBtn.classList.add('visible');
  }

  // Fallback buttons stay hidden ‚Äî speech recognition auto-starts

  // ===== EVENT LISTENERS =====
  playBtn.addEventListener('click', () => {
    initAudio();
    playTapSound();
    resetProgress();
    startLevel(1);
    startBGM();
  });

  continueBtn.addEventListener('click', () => {
    initAudio();
    playTapSound();
    startBGM();
    const saved = loadProgress();
    if (saved) {
      gameState.totalStars = saved.totalStars || 0;
      gameState.completedLevels = saved.completedLevels || [];
      const nextLevel = Math.min(
        (saved.completedLevels.length > 0 ? Math.max(...saved.completedLevels) + 1 : 1),
        LEVEL_COUNT
      );
      startLevel(nextLevel);
    } else {
      startLevel(1);
    }
  });

  micBtn.addEventListener('click', () => {
    if (micBtn.disabled) return;
    playTapSound();
    if (recognitionActive) {
      stopRecognition();
    } else {
      startRecognition();
    }
  });

  hintBtn.addEventListener('click', () => {
    playTapSound();
    const word = getCurrentWord();
    if (word) speakWord(word.reading);
  });

  nextBtn.addEventListener('click', () => {
    playTapSound();
    advanceToNextWord();
  });

  levelNextBtn.addEventListener('click', () => {
    initAudio();
    playTapSound();
    if (gameState.currentLevel >= LEVEL_COUNT) {
      showAllClear();
    } else {
      startLevel(gameState.currentLevel + 1);
    }
  });

  restartBtn.addEventListener('click', () => {
    playTapSound();
    stopBGM();
    resetProgress();
    showScreen(splashScreen);
    continueBtn.classList.remove('visible');
  });

  soundToggle.addEventListener('click', () => {
    gameState.soundEnabled = !gameState.soundEnabled;
    soundToggle.textContent = gameState.soundEnabled ? '‚ô™' : 'üîá';
    if (gameState.soundEnabled) {
      playTapSound();
      startBGM();
    } else {
      stopBGM();
    }
  });

  homeBtn.addEventListener('click', () => {
    playTapSound();
    stopRecognition();
    stopBGM();
    hideOverlays();
    showScreen(splashScreen);
    const saved = loadProgress();
    if (saved && saved.completedLevels && saved.completedLevels.length > 0) {
      continueBtn.classList.add('visible');
    }
  });

  // Fallback mode buttons
  fallbackCorrectBtn.addEventListener('click', () => {
    playTapSound();
    showCorrectFeedback();
  });

  fallbackRetryBtn.addEventListener('click', () => {
    playTapSound();
    gameState.attemptsOnCurrentWord++;
    if (gameState.attemptsOnCurrentWord >= 3) {
      showAutoPassHint();
    } else {
      showRetryFeedback();
    }
  });

  // Save on page hide
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') saveProgress();
  });
  window.addEventListener('beforeunload', saveProgress);
}

// ===== PWA: Generate icons + register service worker =====
function generateIcon(size) {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, size, size);
  grad.addColorStop(0, '#FF9FF3');
  grad.addColorStop(1, '#F368E0');
  // Rounded rect
  const r = size * 0.2;
  ctx.beginPath();
  ctx.moveTo(r, 0);
  ctx.lineTo(size - r, 0);
  ctx.quadraticCurveTo(size, 0, size, r);
  ctx.lineTo(size, size - r);
  ctx.quadraticCurveTo(size, size, size - r, size);
  ctx.lineTo(r, size);
  ctx.quadraticCurveTo(0, size, 0, size - r);
  ctx.lineTo(0, r);
  ctx.quadraticCurveTo(0, 0, r, 0);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();
  // Text
  ctx.fillStyle = 'white';
  ctx.font = `900 ${size * 0.55}px "Hiragino Sans", sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('„ÅÇ', size * 0.48, size * 0.55);
  // Star
  ctx.fillStyle = '#FFD700';
  ctx.font = `${size * 0.2}px sans-serif`;
  ctx.fillText('‚òÖ', size * 0.78, size * 0.22);
  return canvas.toDataURL('image/png');
}

// Set apple-touch-icon dynamically
try {
  const iconLink = document.querySelector('link[rel="apple-touch-icon"]');
  if (iconLink) iconLink.href = generateIcon(192);
} catch (e) { /* ignore */ }

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}

// Start the app
init();
</script>
</body>
</html>
